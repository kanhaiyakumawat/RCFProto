/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.4
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

namespace DeltaVSoft.RCFProto {

using System;
using System.Runtime.InteropServices;

/// <summary>
/// Serves up Protocol Buffer-based services to clients, over one or more server transports. 
/// </summary>
public class RcfProtoServer : IDisposable {

    // BEGIN INSERTED CODE

    internal System.Collections.Generic.Dictionary<string, Google.ProtocolBuffers.IService> mPbServices
        = new System.Collections.Generic.Dictionary<string, Google.ProtocolBuffers.IService>();

    internal SwigCallback_ServerRpc mCallbackTable;

    public void BindService(Google.ProtocolBuffers.IService svc)
    {
        RcfProtoServerImpl.BindService(this, svc);
    }

    // END INSERTED CODE

    
  private HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal RcfProtoServer(IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new HandleRef(this, cPtr);
  }

  internal static HandleRef getCPtr(RcfProtoServer obj) {
    return (obj == null) ? new HandleRef(null, IntPtr.Zero) : obj.swigCPtr;
  }

  ~RcfProtoServer() {
    Dispose();
  }

  public virtual void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          RCFProtoPINVOKE.delete_RcfProtoServer(swigCPtr);
        }
        swigCPtr = new HandleRef(null, IntPtr.Zero);
      }
      GC.SuppressFinalize(this);
    }
  }

  public RcfProtoServer() : this(RCFProtoPINVOKE.new_RcfProtoServer__SWIG_0(), true) {
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  public RcfProtoServer(Endpoint endpoint) : this(RCFProtoPINVOKE.new_RcfProtoServer__SWIG_1(Endpoint.getCPtr(endpoint)), true) {
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Starts the RCFProto server. 
  /// </summary>
  public void Start() {
    if (mCallbackTable == null) mCallbackTable = new SwigCallback_ServerRpc(this);
    RCFProtoPINVOKE.RcfProtoServer_start(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Stops the RCFProto server. 
  /// </summary>
  public void Stop() {
    RCFProtoPINVOKE.RcfProtoServer_stop(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  internal void _setCallbackTable(_SwigCallback pCallback) {
    RCFProtoPINVOKE.RcfProtoServer__setCallbackTable(swigCPtr, _SwigCallback.getCPtr(pCallback));
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Sets the thread pool the server will use. Thread pools can also be assigned to individual transports. 
  /// </summary>
  public void SetThreadPool(ThreadPool threadPoolPtr) {
    RCFProtoPINVOKE.RcfProtoServer_setThreadPool(swigCPtr, ThreadPool.getCPtr(threadPoolPtr));
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the thread pool the server is using. 
  /// </summary>
  public ThreadPool GetThreadPool() {
    IntPtr cPtr = RCFProtoPINVOKE.RcfProtoServer_getThreadPool(swigCPtr);
    ThreadPool ret = (cPtr == IntPtr.Zero) ? null : new ThreadPool(cPtr, true);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Adds a transport endpoint to the server. 
  /// </summary>
  public ServerTransport AddEndpoint(Endpoint endpoint) {
    ServerTransport ret = new ServerTransport(RCFProtoPINVOKE.RcfProtoServer_addEndpoint(swigCPtr, Endpoint.getCPtr(endpoint)), false);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the list of supported protocols the server supports. Clients that connect without using one of the supported protocols are dropped. If the list of supported protocols is empty, all protocols are allowed. Note that supported protocols can also be specified on a server transport, in which case the server transport setting overrides the server setting. 
  /// </summary>
  public void SetSupportedTransportProtocols(TransportProtocolList protocols) {
    RCFProtoPINVOKE.RcfProtoServer_setSupportedTransportProtocols(swigCPtr, TransportProtocolList.getCPtr(protocols));
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the list of supported protocols for the server. 
  /// </summary>
  public TransportProtocolList GetSupportedTransportProtocols() {
    TransportProtocolList ret = new TransportProtocolList(RCFProtoPINVOKE.RcfProtoServer_getSupportedTransportProtocols(swigCPtr), false);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the session timeout value, in milliseconds. Client connections that are idle for this amount of time will be dropped by the server. 
  /// </summary>
  public void SetSessionTimeoutMs(uint sessionTimeoutMs) {
    RCFProtoPINVOKE.RcfProtoServer_setSessionTimeoutMs(swigCPtr, sessionTimeoutMs);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the session timeout value, in milliseconds. 
  /// </summary>
  public uint GetSessionTimeoutMs() {
    uint ret = RCFProtoPINVOKE.RcfProtoServer_getSessionTimeoutMs(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the session harvesting interval, in milliseconds. This setting determines how often the server will scan for idle client connections. 
  /// </summary>
  public void SetSessionHarvestingIntervalMs(uint sessionHarvestingIntervalMs) {
    RCFProtoPINVOKE.RcfProtoServer_setSessionHarvestingIntervalMs(swigCPtr, sessionHarvestingIntervalMs);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the session harvesting interval, in milliseconds. 
  /// </summary>
  public uint GetSessionHarvestingIntervalMs() {
    uint ret = RCFProtoPINVOKE.RcfProtoServer_getSessionHarvestingIntervalMs(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the SSL certificate of the server. 
  /// </summary>
  public void SetCertificate(Certificate certificatePtr) {
    RCFProtoPINVOKE.RcfProtoServer_setCertificate(swigCPtr, Certificate.getCPtr(certificatePtr));
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the SSL certificate of the server. 
  /// </summary>
  public Certificate GetCertificate() {
    IntPtr cPtr = RCFProtoPINVOKE.RcfProtoServer_getCertificate(swigCPtr);
    Certificate ret = (cPtr == IntPtr.Zero) ? null : new Certificate(cPtr, true);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the OpenSSL cipher suite. Only applicable when OpenSSL is used as the SSL implementation. 
  /// </summary>
  public void SetOpenSslCipherSuite(string cipherSuite) {
    RCFProtoPINVOKE.RcfProtoServer_setOpenSslCipherSuite(swigCPtr, cipherSuite);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the OpenSSL cipher suite. 
  /// </summary>
  public string GetOpenSslCipherSuite() {
    string ret = RCFProtoPINVOKE.RcfProtoServer_getOpenSslCipherSuite(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the SSL certificate authority of the server. 
  /// </summary>
  public void SetCaCertificate(Certificate certificatePtr) {
    RCFProtoPINVOKE.RcfProtoServer_setCaCertificate(swigCPtr, Certificate.getCPtr(certificatePtr));
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the SSL certificate authority of the server. 
  /// </summary>
  public Certificate GetCaCertificate() {
    IntPtr cPtr = RCFProtoPINVOKE.RcfProtoServer_getCaCertificate(swigCPtr);
    Certificate ret = (cPtr == IntPtr.Zero) ? null : new Certificate(cPtr, true);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the Schannel certificate validation setting. Only applicable when using Schannel as the SSL implementation. If this setting is non-empty, it will be used by Schannel to automatically validate peer certificates. 
  /// </summary>
  public void SetEnableSchannelCertificateValidation(string peerName) {
    RCFProtoPINVOKE.RcfProtoServer_setEnableSchannelCertificateValidation(swigCPtr, peerName);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the Schannel certificate validation setting. 
  /// </summary>
  public string GetEnableSchannelCertificateValidation() {
    string ret = RCFProtoPINVOKE.RcfProtoServer_getEnableSchannelCertificateValidation(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void SetSslImplementation(SslImplementation sslImplementation) {
    RCFProtoPINVOKE.RcfProtoServer_setSslImplementation(swigCPtr, (int)sslImplementation);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the SSL implementation of the server. 
  /// </summary>
  public SslImplementation GetSslImplementation() {
    SslImplementation ret = (SslImplementation)RCFProtoPINVOKE.RcfProtoServer_getSslImplementation(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}
