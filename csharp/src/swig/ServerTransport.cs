/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.4
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

namespace DeltaVSoft.RCFProto {

using System;
using System.Runtime.InteropServices;

/// <summary>
/// Base class for all server transports. 
/// </summary>
public class ServerTransport : IDisposable {
  private HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal ServerTransport(IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new HandleRef(this, cPtr);
  }

  internal static HandleRef getCPtr(ServerTransport obj) {
    return (obj == null) ? new HandleRef(null, IntPtr.Zero) : obj.swigCPtr;
  }

  ~ServerTransport() {
    Dispose();
  }

  public virtual void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          RCFProtoPINVOKE.delete_ServerTransport(swigCPtr);
        }
        swigCPtr = new HandleRef(null, IntPtr.Zero);
      }
      GC.SuppressFinalize(this);
    }
  }

  /// <summary>
  /// Returns the transport type of this server transport. 
  /// </summary>
  public virtual TransportType GetTransportType() {
    TransportType ret = (TransportType)RCFProtoPINVOKE.ServerTransport_getTransportType(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets maximum incoming message length. Incoming messages that are larger than this size will be dropped. 
  /// </summary>
  public ServerTransport SetMaxIncomingMessageLength(uint maxMessageLength) {
    ServerTransport ret = new ServerTransport(RCFProtoPINVOKE.ServerTransport_setMaxIncomingMessageLength(swigCPtr, maxMessageLength), false);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Returns maximum incoming message length. 
  /// </summary>
  public uint GetMaxIncomingMessageLength() {
    uint ret = RCFProtoPINVOKE.ServerTransport_getMaxIncomingMessageLength(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the maximum number of simultaneous connections to the server transport. 
  /// </summary>
  public ServerTransport SetConnectionLimit(uint connectionLimit) {
    ServerTransport ret = new ServerTransport(RCFProtoPINVOKE.ServerTransport_setConnectionLimit(swigCPtr, connectionLimit), false);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Returns the maximum number of simultaneous connections to the server transport. 
  /// </summary>
  public uint GetConnectionLimit() {
    uint ret = RCFProtoPINVOKE.ServerTransport_getConnectionLimit(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the initial number of listening connections that are created when the server transport starts. 
  /// </summary>
  public ServerTransport SetInitialNumberOfConnections(uint initialNumberOfConnections) {
    ServerTransport ret = new ServerTransport(RCFProtoPINVOKE.ServerTransport_setInitialNumberOfConnections(swigCPtr, initialNumberOfConnections), false);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Returns the initial number of listening connections that are created when the server transport starts. 
  /// </summary>
  public uint GetInitialNumberOfConnections() {
    uint ret = RCFProtoPINVOKE.ServerTransport_getInitialNumberOfConnections(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the thread pool that the server transport will use. 
  /// </summary>
  public ServerTransport SetThreadPool(ThreadPool threadPoolPtr) {
    ServerTransport ret = new ServerTransport(RCFProtoPINVOKE.ServerTransport_setThreadPool(swigCPtr, ThreadPool.getCPtr(threadPoolPtr)), false);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the list of supported protocols the server transport supports. Clients that connect without using one of the supported protocols are dropped. If the list of supported protocols is empty, all protocols are allowed. 
  /// </summary>
  public ServerTransport SetSupportedProtocols(TransportProtocolList protocols) {
    ServerTransport ret = new ServerTransport(RCFProtoPINVOKE.ServerTransport_setSupportedProtocols(swigCPtr, TransportProtocolList.getCPtr(protocols)), false);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public TransportProtocolList GetSupportedProtocols() {
    TransportProtocolList ret = new TransportProtocolList(RCFProtoPINVOKE.ServerTransport_getSupportedProtocols(swigCPtr), false);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}
