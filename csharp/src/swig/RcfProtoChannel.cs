/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.4
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

namespace DeltaVSoft.RCFProto {

using System;
using System.Runtime.InteropServices;

/// <summary>
/// Represents a single RPC connection to a server. 
/// </summary>
public class RcfProtoChannel : IDisposable, Google.ProtocolBuffers.IRpcChannel {

    // BEGIN INSERTED CODE
    public virtual void CallMethod(
        Google.ProtocolBuffers.Descriptors.MethodDescriptor method,
        Google.ProtocolBuffers.IRpcController controller,
        Google.ProtocolBuffers.IMessage request,
        Google.ProtocolBuffers.IMessage responsePrototype,
        Action<Google.ProtocolBuffers.IMessage> done)
    {
        RcfProtoChannelImpl.CallMethod(this, method, controller, request, responsePrototype, done);
    }

    public Google.ProtocolBuffers.IMessage GetResponse()
    {
        return RcfProtoChannelImpl.GetResponse(this);
    }

    public void SetCertificateValidationCallback(
        CertificateValidationCallback certificateValidator)
    {
        RcfProtoChannelImpl.SetCertificateValidationCallback(this, certificateValidator);
    }

    internal Google.ProtocolBuffers.IMessage            mResponse;
    internal string                                     mResponseError;

    internal SwigCallback_CallCompletion                mSwigCallback;
    internal Action<Google.ProtocolBuffers.IMessage>    mDone;
    internal Google.ProtocolBuffers.IMessage            mResponsePrototype;
    internal SwigCallback_Certificate                   mSwigCallbackCertificate;
    // END INSERTED CODE

    
  private HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal RcfProtoChannel(IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new HandleRef(this, cPtr);
  }

  internal static HandleRef getCPtr(RcfProtoChannel obj) {
    return (obj == null) ? new HandleRef(null, IntPtr.Zero) : obj.swigCPtr;
  }

  ~RcfProtoChannel() {
    Dispose();
  }

  public virtual void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          RCFProtoPINVOKE.delete_RcfProtoChannel(swigCPtr);
        }
        swigCPtr = new HandleRef(null, IntPtr.Zero);
      }
      GC.SuppressFinalize(this);
    }
  }

  internal void _CallMethodSwig(string serviceName, int methodId, byte[] szBuffer, int szBufferLen, _SwigCallback closure) {
    RCFProtoPINVOKE.RcfProtoChannel__CallMethodSwig(swigCPtr, serviceName, methodId, szBuffer, szBufferLen, _SwigCallback.getCPtr(closure));
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  internal int _GetResponseBufferLength() {
    int ret = RCFProtoPINVOKE.RcfProtoChannel__GetResponseBufferLength(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  internal void _GetResponseBuffer(byte[] szBuffer, int bufferLen) {
    RCFProtoPINVOKE.RcfProtoChannel__GetResponseBuffer(swigCPtr, szBuffer, bufferLen);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Constructs a RPC channel from an endpoint. 
  /// </summary>
  public RcfProtoChannel(Endpoint endpoint) : this(RCFProtoPINVOKE.new_RcfProtoChannel(Endpoint.getCPtr(endpoint)), true) {
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  internal void _CallMethodSwig_WithCopy(string serviceName, int methodId, string strBuffer, _SwigCallback closure) {
    RCFProtoPINVOKE.RcfProtoChannel__CallMethodSwig_WithCopy(swigCPtr, serviceName, methodId, strBuffer, _SwigCallback.getCPtr(closure));
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  internal string _GetResponseBuffer_WithCopy() {
    string ret = RCFProtoPINVOKE.RcfProtoChannel__GetResponseBuffer_WithCopy(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// After a call has finished, returns true if the call failed.  The possible reasons for failure depend on the RPC implementation.  Failed() must not be called before a call has finished.  If Failed() returns true, the contents of the response message are undefined. 
  /// </summary>
  public bool Failed() {
    bool ret = RCFProtoPINVOKE.RcfProtoChannel_Failed(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// If Failed() is true, returns a human-readable description of the error. 
  /// </summary>
  public string ErrorText() {
    string ret = RCFProtoPINVOKE.RcfProtoChannel_ErrorText(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Advises the RPC system that the caller desires that the RPC call be canceled.  The RPC system may cancel it immediately, may wait awhile and then cancel it, or may not even cancel the call at all.  If the call is canceled, the "done" callback will still be called and the RpcController will indicate that the call failed at that time. 
  /// </summary>
  public void StartCancel() {
    RCFProtoPINVOKE.RcfProtoChannel_StartCancel(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  public bool Completed() {
    bool ret = RCFProtoPINVOKE.RcfProtoChannel_Completed(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Connects to the server. 
  /// </summary>
  public void Connect() {
    RCFProtoPINVOKE.RcfProtoChannel_connect(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Disconencts from the server. 
  /// </summary>
  public void Disconnect() {
    RCFProtoPINVOKE.RcfProtoChannel_disconnect(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Sets the remote call timeout value, in milliseconds. 
  /// </summary>
  public void SetRemoteCallTimeoutMs(uint remoteCallTimeoutMs) {
    RCFProtoPINVOKE.RcfProtoChannel_setRemoteCallTimeoutMs(swigCPtr, remoteCallTimeoutMs);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the remote call timeout value, in milliseconds. 
  /// </summary>
  public uint GetRemoteCallTimeoutMs() {
    uint ret = RCFProtoPINVOKE.RcfProtoChannel_getRemoteCallTimeoutMs(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the connect timeout value, in milliseconds. 
  /// </summary>
  public void SetConnectTimeoutMs(uint connectTimeoutMs) {
    RCFProtoPINVOKE.RcfProtoChannel_setConnectTimeoutMs(swigCPtr, connectTimeoutMs);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the connect timeout value, in milliseconds. 
  /// </summary>
  public uint GetConnectTimeoutMs() {
    uint ret = RCFProtoPINVOKE.RcfProtoChannel_getConnectTimeoutMs(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the transport protocol being used by the channel. 
  /// </summary>
  public void SetTransportProtocol(TransportProtocol protocol) {
    RCFProtoPINVOKE.RcfProtoChannel_setTransportProtocol(swigCPtr, (int)protocol);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the transport protocol being used by the channel. 
  /// </summary>
  public TransportProtocol GetTransportProtocol() {
    TransportProtocol ret = (TransportProtocol)RCFProtoPINVOKE.RcfProtoChannel_getTransportProtocol(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the asynchronous RPC mode. By default the asynchronous RPC mode is false. 
  /// </summary>
  public void SetAsynchronousRpcMode(bool enable) {
    RCFProtoPINVOKE.RcfProtoChannel_setAsynchronousRpcMode(swigCPtr, enable);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the asynchronous RPC mode. 
  /// </summary>
  public bool GetAsynchronousRpcMode() {
    bool ret = RCFProtoPINVOKE.RcfProtoChannel_getAsynchronousRpcMode(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the ping back interval of the connection, in milliseconds. Ping backs are sent from the server back to the client, while a remote call is in progress. 
  /// </summary>
  public void SetPingBackIntervalMs(int pingBackIntervalMs) {
    RCFProtoPINVOKE.RcfProtoChannel_setPingBackIntervalMs(swigCPtr, pingBackIntervalMs);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the ping back interval of the connection. 
  /// </summary>
  public int GetPingBackIntervalMs() {
    int ret = RCFProtoPINVOKE.RcfProtoChannel_getPingBackIntervalMs(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the network address of the HTTP proxy server, through which to route remote calls. Only valid when using a HTTP or HTTPS endpoint. 
  /// </summary>
  public void SetHttpProxy(string httpProxy) {
    RCFProtoPINVOKE.RcfProtoChannel_setHttpProxy(swigCPtr, httpProxy);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the network address of the HTTP proxy server. 
  /// </summary>
  public string GetHttpProxy() {
    string ret = RCFProtoPINVOKE.RcfProtoChannel_getHttpProxy(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the port number of the HTTP proxy server, through which to route remote calls. Only valid when using a HTTP or HTTPS endpoint. 
  /// </summary>
  public void SetHttpProxyPort(int httpProxyPort) {
    RCFProtoPINVOKE.RcfProtoChannel_setHttpProxyPort(swigCPtr, httpProxyPort);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the port number of the HTTP proxy server. 
  /// </summary>
  public int GetHttpProxyPort() {
    int ret = RCFProtoPINVOKE.RcfProtoChannel_getHttpProxyPort(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Returns the transport type of the connection. 
  /// </summary>
  public TransportType GetTransportType() {
    TransportType ret = (TransportType)RCFProtoPINVOKE.RcfProtoChannel_getTransportType(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the Windows username to use when connecting. Only valid for NTLM and Kerberos transport protocols. 
  /// </summary>
  public void SetUsername(string username) {
    RCFProtoPINVOKE.RcfProtoChannel_setUsername(swigCPtr, username);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the Windows username to use when connecting. 
  /// </summary>
  public string GetUsername() {
    string ret = RCFProtoPINVOKE.RcfProtoChannel_getUsername(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the Windows password to use when connecting. Only valid for NTLM and Kerberos transport protocols. 
  /// </summary>
  public void SetPassword(string password) {
    RCFProtoPINVOKE.RcfProtoChannel_setPassword(swigCPtr, password);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the Windows password to use when connecting. 
  /// </summary>
  public string GetPassword() {
    string ret = RCFProtoPINVOKE.RcfProtoChannel_getPassword(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the Kerberos SPN to use when connecting. Only valid for Kerberos transport protocols. 
  /// </summary>
  public void SetKerberosSpn(string kerberosSpn) {
    RCFProtoPINVOKE.RcfProtoChannel_setKerberosSpn(swigCPtr, kerberosSpn);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the Kerberos SPN to use when connecting. 
  /// </summary>
  public string GetKerberosSpn() {
    string ret = RCFProtoPINVOKE.RcfProtoChannel_getKerberosSpn(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the transport level compression setting for this connection. 
  /// </summary>
  public void SetEnableCompression(bool enableCompression) {
    RCFProtoPINVOKE.RcfProtoChannel_setEnableCompression(swigCPtr, enableCompression);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Returns the transport level compression setting for this connection. 
  /// </summary>
  public bool GetEnableCompression() {
    bool ret = RCFProtoPINVOKE.RcfProtoChannel_getEnableCompression(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the SSL certificate for the channel. 
  /// </summary>
  public void SetCertificate(Certificate certificatePtr) {
    RCFProtoPINVOKE.RcfProtoChannel_setCertificate(swigCPtr, Certificate.getCPtr(certificatePtr));
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the SSL certificate for the channel. 
  /// </summary>
  public Certificate GetCertificate() {
    IntPtr cPtr = RCFProtoPINVOKE.RcfProtoChannel_getCertificate(swigCPtr);
    Certificate ret = (cPtr == IntPtr.Zero) ? null : new Certificate(cPtr, true);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the certificate authority for the channel. 
  /// </summary>
  public void SetCaCertificate(Certificate certificatePtr) {
    RCFProtoPINVOKE.RcfProtoChannel_setCaCertificate(swigCPtr, Certificate.getCPtr(certificatePtr));
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the certificate authority for the channel. 
  /// </summary>
  public Certificate GetCaCertificate() {
    IntPtr cPtr = RCFProtoPINVOKE.RcfProtoChannel_getCaCertificate(swigCPtr);
    Certificate ret = (cPtr == IntPtr.Zero) ? null : new Certificate(cPtr, true);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the OpenSSL cipher suite. Only applicable when using OpenSSL as the SSL implementation. 
  /// </summary>
  public void SetOpenSslCipherSuite(string cipherSuite) {
    RCFProtoPINVOKE.RcfProtoChannel_setOpenSslCipherSuite(swigCPtr, cipherSuite);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the OpenSSL cipher suite. 
  /// </summary>
  public string GetOpenSslCipherSuite() {
    string ret = RCFProtoPINVOKE.RcfProtoChannel_getOpenSslCipherSuite(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>
  /// Sets the Schannel certificate validation setting. Only applicable when using Schannel as the SSL implementation. If this setting is non-empty, it will be used by Schannel to automatically validate peer certificates. 
  /// </summary>
  public void SetEnableSchannelCertificateValidation(string peerName) {
    RCFProtoPINVOKE.RcfProtoChannel_setEnableSchannelCertificateValidation(swigCPtr, peerName);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the Schannel certificate validation setting. 
  /// </summary>
  public string GetEnableSchannelCertificateValidation() {
    string ret = RCFProtoPINVOKE.RcfProtoChannel_getEnableSchannelCertificateValidation(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  internal void _setCertificateValidationCallback(_SwigCallback pcb) {
    RCFProtoPINVOKE.RcfProtoChannel__setCertificateValidationCallback(swigCPtr, _SwigCallback.getCPtr(pcb));
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Sets the SSL implementation to be used by the channel. 
  /// </summary>
  public void SetSslImplementation(SslImplementation sslImplementation) {
    RCFProtoPINVOKE.RcfProtoChannel_setSslImplementation(swigCPtr, (int)sslImplementation);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>
  /// Gets the SSL implementation. 
  /// </summary>
  public SslImplementation GetSslImplementation() {
    SslImplementation ret = (SslImplementation)RCFProtoPINVOKE.RcfProtoChannel_getSslImplementation(swigCPtr);
    if (RCFProtoPINVOKE.SWIGPendingException.Pending) throw RCFProtoPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}
